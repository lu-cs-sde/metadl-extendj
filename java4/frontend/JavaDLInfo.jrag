aspect JavaDLInfo {
	public Object ASTNode.javaDLInfo = null;
	public int ASTNode.javaDLNum = -1;
	public int ASTNode.javaDLFileId = -1;
	public boolean ASTNode.visitedMarker = false;
	public long ASTNode.javaDLNodeId = -1;

	public Object ASTNode.type() { return null; }
	public Object ASTNode.decl() { return null; }
	public Object ASTNode.genericDecl() { return null; }
	public boolean ASTNode.isGeneric() { return false; }
	public boolean ParTypeDecl.isGeneric() { return true; }

	/** Perform node numbering for NTAs. We do this depth-first, just
		because it's easier to implement. */
	public long ASTNode.doNodeNumberingNTA(long start, Map<ASTNode, Long> nodeToId) {
		nodeToId.put(this, start);
		start++;

		// number the children first
		for (int i = 0; i < getNumChildNoTransform(); ++i) {
			ASTNode child = getChildNoTransform(i);
			if (child != null) {
				start = child.doNodeNumberingNTA(start, nodeToId);
				if (getChild(i) != child) {
					start = getChild(i).doNodeNumberingNTA(start, nodeToId);
				}
			}
		}

		return start;
	}

	/**
		Node numbering for AST nodes (including rewritten ones). Set last = null,
		to number all nodes.
	 */
	private Queue<ASTNode> CompilationUnit.nodeNumberingQueue = new ArrayDeque<ASTNode>(Collections.<ASTNode>singleton(this));
	private int CompilationUnit.currentNodeIdx = 1;
	public boolean CompilationUnit.numberNodesUntil(ASTNode last, int fileId, Map<ASTNode, Long> nodeToId, boolean visitRewrittenChildren) {
		while (!nodeNumberingQueue.isEmpty()) {
			ASTNode n = nodeNumberingQueue.poll();
			nodeToId.put(n, (((long) fileId) << 32) | currentNodeIdx);
			currentNodeIdx++;
			for (int i = 0; i < n.getNumChildNoTransform(); ++i) {
				ASTNode childNT = n.getChildNoTransform(i);
				if (childNT == null)
					continue;
				nodeNumberingQueue.add(childNT);
				if (visitRewrittenChildren && childNT.mayHaveRewrite()) {
					ASTNode child = n.getChild(i);
					if (child != childNT && child != null) {
						nodeNumberingQueue.add(child);
					}
				}
			}

			if (n == last) {
				// we reached the node we wanted to be numbered; return
				return true;
			}
		}
		// we haven't found the node to be numbered;
		// this should not happen, but maybe it does
		return false;
	}

	public void ASTNode.printNodesBelow() {
		System.out.println(this);
		if (getParent() != null)
			getParent().printNodesBelow();
	}

	/**
	   Find the compilation unit for this node, if it's not
	   an NTA.
	 */
	syn lazy CompilationUnit ASTNode.parentCompilationUnit() {
		if (this instanceof CompilationUnit) {
			return (CompilationUnit) this;
		}
		if (getParent() != null) {
			ASTNode parent = getParent();
			if (parent.getIndexOfChild(this) >= 0 &&
				parent.getIndexOfChild(this) < parent.getNumChild()) {
				// check that the child is not an NTA child
				return getParent().parentCompilationUnit();
			}
		}

		return null;
	}

	/**
	   Number this node on-demand. The numbering is successful if this
	   is a non-NTA node (may be a rewritten node).
	 */
	public boolean ASTNode.numberOnDemand(FileIdStorage fidStorage, Map<ASTNode, Long> nodeToId) {
		CompilationUnit cu = parentCompilationUnit();
		if (cu == null)
			return false;
		int fileId = fidStorage.getIdForLib(cu.getClassSource().relativeName());
		return cu.numberNodesUntil(this, fileId, nodeToId, cu.fromSource());
	}

	public interface FileIdStorage {
		int getIdForFile(String file);
		int getIdForLib(String lib);
	}

	public FileIdStorage Program.fileIdStorage = null;

	syn lazy int ASTNode.rpoNum() {
		if (getNumChild() != 0) {
			ASTNode lastChild = getChild(getNumChild() - 1);
			if (lastChild.rpoNum() != NTACHILD)
				return lastChild.rpoNum() + 1;
			return NTACHILD;
		} else {
			int ls = leftSiblingsRpoNum();
			if (ls != NTACHILD)
				return ls + 1;
			else
				return NTACHILD;
		}
	}

	static int ASTNode.NOLEFTSIBLING = -1;
	static int ASTNode.NTACHILD = -2;

	inh lazy int ASTNode.leftSiblingsRpoNum();
	eq ASTNode.getChild(int i).leftSiblingsRpoNum() {
		if (i == 0) {
			if (this instanceof CompilationUnit)
				return NOLEFTSIBLING;
			else return leftSiblingsRpoNum();
		} else if (i > 0) {
			return getChild(i - 1).rpoNum();
		} else {
			// i < 0, this is not a proper child, it is an NTA
			return NTACHILD;
		}
	}

	inh lazy ASTNode ASTNode.leftSibling();

	eq ASTNode.getChild(int i).leftSibling() {
		if (i == 0) {
			if (this instanceof CompilationUnit)
				return null;
			return this.leftSibling();
		} else {
			return getChild(i - 1);
		}
	}

	inh ASTNode ASTNode.rewrittenFrom();
	eq ASTNode.getChild(int i).rewrittenFrom() {
		if (i < 0)
			return null;

		if (getChildNoTransform(i) != getChild(i))
			return getChildNoTransform(i);
		return null;
	}

	syn ASTNode ASTNode.rewrittenTo() {
		if (!canRewrite())
			return null;
		return rewrittenNode();
	}
}
